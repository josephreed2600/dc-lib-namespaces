# Namespaces:
#  2 dc
#  3 row
#  6 matrix
# Functions:
#  (dc)D: General delete function, removes TOS silently
#  (matrix)P: Print matrix(m,n)
#  (matrix)E: Fetch element i,j from matrix(m,n)
#  (matrix)W: Write one value to row i, column j
#  (matrix)I: Generate an identity matrix
#  (matrix)C: Scalar matrix multiplication
#  (matrix)R: Perform row reduction on a matrix
#  (matrix)D: Calculate the determinant
#  (matrix)+: Add scalar multiples of two matrices
#  (matrix)*: Matrix multiplication
#  (row)R: Extract a row i from a matrix
#  (row)W: Write n values to row i of matrix(m,n)
#  (row)S: Swap rows u and v in matrix(m,n)
#  (row)O: Perform generic operation on row i
#  (row)+: Row addition
# Replace one name with another, like O->Y:
#   ([=<>LSls])O(x?)
#   \1Y\2
# Or A->(matrix)+:
#   sA
#   [matrix]Z:+
# s/([Ll])cx)/[row]\1Ox/
# s/([Ss])c/[row]Z:O/
#
# Namespace prep:
#   s/(.)/[Z;\1x]s\1/
[Z;Cx]sC
[Z;Dx]sD
[Z;Ex]sE
[Z;Ix]sI
[Z;Ox]sO
[Z;Px]sP
[Z;Rx]sR
[Z;Sx]sS
[Z;Wx]sW
[Z;+x]s+
[Z;*x]s*



# 1 2 3 4 5 6 7 8 9 2 4 6 9 6 3 
# 5 3

# 1 2 3
# 4 5 6
# 7 8 9
# 2 4 6
# 9 6 3


[Z0*K+k][dc]Z:D # (dc)D: General delete function, removes TOS silently

# 5sk [lXx lk1-dsk 0<L]sL lk0<L # execute X for k=5..1 if k=5
# 5sk [lXx lkd1-sk 0<L]sL lk0<L # execute X for k=5..0 if k=5
# 5sk [lXx lkd1-sk 0<L]dsLx     # execute X for k=5..1 or for k=0
# 5sk [lXx lk1-dsk 0<L]dsLx     # execute X for k=5..1 or for k=0

# (row)R: Extract a row i from a matrix
# @return matrix row | TOS
# matrix elements entered in reading order numRows numCols | TOS
[
 Si  # Requesting row i
 Sn  # A has n columns
 Sm  # A has m rows
 0Sk
 []SL
 
# [Fetching row ]n lin [ from a matrix with ]n lmn [ rows and ]n lnn [ columns]nAP
 
 # The first i-1 rows have (i-1)*n elements
 # Therefore, skip the first (i-1)*n elements by pushing them onto a named stack A
 #  Try the number of elements in the last m-i rows: (m-i)*n
# [Skipping ]n lmli-ln*n [ elements]nAP
 lmli-ln*sk [SA lk1-dsk 0<L]sL lk0<L
 
 # Row i has n elements
 # Therefore, copy the next n elements by pushing them onto a named stack B along with a stack named A
# [Copying ]n lnn [ elements]nAP
 lnsk [dSBSA lk1-dsk 0<L]sL lk0<L
 
 # Restore the first (i-1)*n + n elements from stack A
 #  Try using last elements again: (m-i)*n + n = (m-i+1)*n
# [Restoring ]n lmli1--ln*n [ elements]nAP
 lmli1--ln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 # Restore the n elements that we copied into stack B
# [Restoring ]n lnn [ copied elements]nAP
 lnsk [LB lk1-dsk 0<L]sL lk0<L
 
 
 0LLZ*Li*Lk*Lm*Ln*K+k
] [row]Z:R

# (matrix)E: Fetch element i,j from matrix(m,n)
# @return matrix, element
[
 Sj  # Tgt col j
 Si  # Tgt row i
 Sn  # n cols
 Sm  # m rows
 0Sk
 []SL
 
 lm ln li [row]lRx # get the ith row of matrix(m,n)
 ln  1 lj [row]lRx # get the jth row of matrix(n,1), which is row n transposed
 Se  # Store element as e temporarily
 # We now have n garbage values to destroy
 lnsk [[dc]lDx lk1-dsk 0<L]sL lk0<L # so let's delete them
 Le  # Restore element
 
 0LLZ*Li*Lj*Lk*Lm*Ln*K+k
][matrix]Z:E

# (matrix)W: Write one value to row i, column j
# @return matrix
#  n*(m-i)+(n-j)
#  nm-ni+n-j
#  n(m-n+1)-j
#  lmln-1+ln*lj- # number of elements after i,j
# your matrix newValue rows cols row col | TOS
# your matrix    v       m    n   i   j  | TOS
[
 Sj
 Si
 Sn
 Sm
 Sv
 0Sk
 
 # Move the last n*(m-i)+(n-j) elements into stack A
 lmli-1+ln*lj-sk [SA lk1-dsk 0<L]sL lk0<L
 # Delete existing element
 [dc]lDx
 # Insert new element
 Lv
 # Restore last bunch of elements from stack A
 lmli-1+ln*lj-sk [LA lk1-dsk 0<L]sL lk0<L
 
 0LLZ*Lk*Li*Lj*Lm*Ln*K+k
] [matrix]Z:W

# (row)W: Write n values to row i of matrix(m,n)
# @return matrix
# matrix values your new row here m n i | TOS
[
 Si
 Sn
 Sm
 0Sk
 []SL
 
 # Push new row of length n onto stack I
 lnsk [SI lk1-dsk 0<L]sL lk0<L
 
 # Push last m-i rows onto stack A
 lmli-ln*sk [SA lk1-dsk 0<L]sL lk0<L
 
 # Delete last n elements, which comprise the existing row i
 lnsk [[dc]lDx lk1-dsk 0<L]sL lk0<L
 
 # Copy in the n elements from stack N
 lnsk [LI lk1-dsk 0<L]sL lk0<L
 
 # Copy back the last m-i rows from stack A
 lmli-ln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 
 0LLZ*Li*Lk*Lm*Ln*K+k
] [row]Z:W

# (row)S: Swap rows u and v in matrix(m,n)
# @return matrix
[
 Sv
 Su
 Sn
 Sm
 0Sk
 
 # Pull row u from matrix
 lm ln lu [row]lRx
 # Store u's n elements on stack U
 lnsk [SU lk1-dsk 0<L]sL lk0<L
 # Pull row v from matrix
 lm ln lv [row]lRx
 # Write row v over row u
 lm ln lu [row]lWx
 # Load u's n elements from stack U
 lnsk [LU lk1-dsk 0<L]sL lk0<L
 # Write row u over row v
 lm ln lv [row]lWx
 
 0Lk*Lm*Ln*Lu*Lv*K+k
] [row]Z:S

# (row)O: Perform generic operation on row i
# @return matrix row | TOS
# your matrix m n i [] | TOS
[
 SY  # operation
 Si  # row index
 Sn
 Sm
 0Sk
 []SL
 
##### Copied from R 
# [Fetching row ]n lin [ from a matrix with ]n lmn [ rows and ]n lnn [ columns]nAP
 
 # The first i-1 rows have (i-1)*n elements
 # Therefore, skip the first (i-1)*n elements by pushing them onto a named stack A
 #  Try the number of elements in the last m-i rows: (m-i)*n
# [Skipping ]n lmli-ln*n [ elements]nAP
 lmli-ln*sk [SA lk1-dsk 0<L]sL lk0<L
 
 # Row i has n elements
 # Therefore, copy the next n elements by pushing them onto a named stack B along with a stack named A
# [Copying ]n lnn [ elements]nAP
 lnsk [dSBSA lk1-dsk 0<L]sL lk0<L
 
 # Restore the first (i-1)*n + n elements from stack A
 #  Try using last elements again: (m-i)*n + n = (m-i+1)*n
# [Restoring ]n lmli1--ln*n [ elements]nAP
 lmli1--ln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 # Restore the n elements that we copied into stack B
# [Restoring ]n lnn [ copied elements]nAP
 lnsk [LBlYx lk1-dsk 0<L]sL lk0<L    # This is the only change from R: s/LB/LBlYx/
##### 
 
 
 0LLZ*LYZ*Li*Lk*Lm*Ln*K+k
] [row]Z:O

# C: Scalar matrix multiplication
# @return matrix, c*matrix
# your matrix m n scalar | TOS
[
 Ss
 * 1 r 1 [ls*] [row]lOx
 0Ls*K+k
] [matrix]Z:C

# (row)+: Row addition
## u := s*u + p*v
# u,v are rows; s,p are scalars
# @return matrix, row
# your matrix m n u s v p | TOS
[
 Sp  # scalar for second row
 Sv  # index of second row
 Ss  # scalar for first row
 Su  # index of first row (row that will be replaced) (not replaced any more)
 Sn  # columns
 Sm  # rows
 0Sk
 []SL
 
 
 # Get s*u
 lm ln lu [ls*] [row]lOx
 # Store s*u on stack U
 lnsk [SU lk1-dsk 0<L]sL lk0<L
 # Get p*v
 lm ln lv [lp*] [row]lOx
 # Store p*v on stack V
 lnsk [SV lk1-dsk 0<L]sL lk0<L
 # Load each item from U and V and add them together
 lnsk [LULV+ lk1-dsk 0<L]sL lk0<L

# Removed: User will determine what to do with sum of rows, in keeping with style of "don't modify the matrix unless that's all it does"
# # Write s*u + p*v over row u
# lm ln lu [row]lWx
 
 0LLZ*Lk*Lm*Ln*Lp*Ls*Lu*Lv*K+k
] [row]Z:+

# (matrix)+: Add scalar multiples of two matrices
# @return A B sA+pB | TOS
# your first matrix your second matrix m n s p | TOS
[
 Sp
 Ss
 Sn
 Sm
 0Sk
 []SL
 
 # Push all m*n elements of second matrix onto stack B
 lmln*sk [SB lk1-dsk 0<L]sL lk0<L
 # Push all m*n elements of first matrix onto stack A
 lmln*sk [SA lk1-dsk 0<L]sL lk0<L
 # For each element:
 #   Copy each pair of elements from A and B
 #   Add A(k)+B(k)
 #   Push each result onto stack C
 #   Load A(k) and B(k)
 lmln*sk [lAls*lBlp*+SCLALB lk1-dsk 0<L]sL lk0<L
 # Now we have C in reverse of the order we need it in,
 # and A and B interleaved on the stack.
 # Separate A and B
 lmln*sk [SBSA lk1-dsk 0<L]sL lk0<L
 # Load A
 lmln*sk [LA lk1-dsk 0<L]sL lk0<L
 # Load B
 lmln*sk [LB lk1-dsk 0<L]sL lk0<L
 # Reverse C into A
 lmln*sk [LCSA lk1-dsk 0<L]sL lk0<L
 # Load C from A
 lmln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 0LLZ*Lk*Lm*Ln*Lp*Ls*K+k
] [matrix]Z:+



# (matrix)*: Matrix multiplication
# @return matrixA, matrixB, matrixAB | TOS
# first matrix second matrix m n p | TOS
[
 Sp  # width of B and C
 Sn  # width of A and height of B
 Sm  # height of A and C
 0Si
 0Sj
 0Sk
 0St
 []SI
 []SJ
 []SK
 []ST
 []SY  # operation for loops
 
 # Reusable loop code:
 # []sY lx lFx
 [st [lYx lt1-dst 0<T]sT lt0<T]SF
 
 lnlp* [SB]sY lFx
 lmln* [SA]sY lFx
 
 # Multiplication algorithm
 lmsi [
       lpsk [
	         0SC
			 lnsj [
			       lmln* [LA]sY lFx
				   lmlnlilj[matrix]lExSC
				   lmln* [SA]sY lFx
				   lnlp* [LB]sY lFx
				   lnlpljlk[matrix]lExSC
				   lnlp* [SB]sY lFx
				   LCLC*LC+SC
				   lj1-dsj 0<J
			      ]sJ lj0<J
			 lk1-dsk 0<K
	        ]sK lk0<K
	   li1-dsi 0<I
      ]sI li0<I
 lmln* [LA]sY lFx
 lnlp* [LB]sY lFx
 lmlp* [LC]sY lFx
 
 0Li*Lj*Lk*Lm*Ln*Lp*Lt*K+k
 0LFZ*LIZ*LJZ*LKZ*LTZ*LYZ*K+k
] [matrix]Z:*

# I: Generate an identity matrix
# @return matrix | TOS
# n | TOS
[
 Sn
 0Sk
 0St
 []SL
 []Sl
 
 1
 # The rest of the matrix is n-1 repetitions of n zeros followed by a 1
 ln1-sk [
         lnst [
			   0 lt1-dst 0<l
	          ]sl lt0<l
	     1
		 lk1-dsk 0<L
        ]sL lk0<L
 
 0LLZ*Lk*Ln*Lt*K+k
] [matrix]Z:I

# (matrix)R: Perform row reduction on a matrix
# @return matrix
# your matrix m n | TOS
[
 KdSZ2*k
 Sn
 Sm
 0Si
 0Sk
# [lmlnlklk1-[row]lSxli1-si]SQ
 [[ Skipping ]nAP LU [dc]lDx [dc]lDx3Q]SQ
 [
#  [ Swapping ]nAP
  LU [dc]lDx [dc]lDx lmlnlkd1-[row]lSx lk1+sk 2Q
 ]SY
 [
# [      F called with i = ]n lin [, k = ]n lknAP
#    [R]n lin [ = (]n

  lmlnlilk[matrix]lExSU
  
#  # Check whether k,k is 0. If it is, we can't perform division, so swap rows k and k-1 and try F again.
#  [(]n lkn [,]n lkn [) == ]n lUnAP
#   lU0=Q
#  # Let's not actually do that just yet
  
  lmlnlklk[matrix]lEx SV
#    lVn [*R]n lin
  d0=Y
#    [ - (]n
  lm ln li lV
#    lUn [)*R]n lkn [)/]n lVn
#  d0=Y
#  AP AP
  _1*
  lk LU
  
  [row]l+x
  lmlnli[row]lWx
  lmlnli[lV/][row]lOx
  lmlnli[row]lWx
  LV[dc]lDx
  
#  lm ln [matrix]lPx AP
# [      F exiting with i = ]n lin [, k = ]n lknAP
 ]SF
 []SI
 []SK

# [ Attempting row reduction on ]n lmn [ by ]n lnn [ matrix:]n AP AP
 #lm ln [matrix]lPx AP
 
 lmsk [
# [  k = ]n lkn [ loop running]nAP
	   lmsi [
#	         [    i = ]n lin [ loop running]nAP
			 lilk!=F
#			 lm ln [matrix]lPx AP
			 li1-dsi 0<I
			]sI li0<I
	   
	   lk1-dsk 0<K
	  ]sK lk0<K
 LZk
 lmsk [
	   lmlnlklk[matrix]lEx
      
#	   [R]n lkn [ /= ]n dn AP AP

	   Ss  # store denominator on `s' for use in `c'
	   lm ln lk [ls/] [row]lOx
	   Ls [dc]lDx  # delete `s'
	   lm ln lk [row]lWx
#	   lm ln [matrix]lPx AP
	   
	   lk1-dsk 0<K
	  ]sK lk0<K
 
 0Li*Lk*Lm*Ln*K+k
 0LFZ*LIZ*LKZ*LYZ*LQZ*K+k
] [matrix]Z:R

# (matrix)D: Calculate the determinant
# @return matrix, determinant | TOS
# your matrix n | TOS
[
 dSn
 Sm
 0Si
 0Sk
# [lmlnlklk1-[row]lSxli1-si]SQ
 [[ Skipping ]nAP LU [dc]lDx [dc]lDx3Q]SQ
 [[ Swapping ]nAP LU [dc]lDx [dc]lDx lmlnlkd1-[row]lSx lk1+sk 2Q]SY
 [
 [      F called with i = ]n lin [, k = ]n lknAP
    [R]n lin [ = (]n

  lmlnlilk[matrix]lExSU
  
#  # Check whether k,k is 0. If it is, we can't perform division, so swap rows k and k-1 and try F again.
#  [(]n lkn [,]n lkn [) == ]n lUnAP
#   lU0=Q
#  # Let's not actually do that just yet
  
  lmlnlklk[matrix]lEx dSVn [*R]n lin d0=Y [ - (]n
  lm ln li lV
  lUn [)*R]n lkn [)/]n lVn
#  d0=Y
  AP AP
  _1*
  lk LU
  
  [row]l+x
  lmlnli[row]lWx
  lmlnli[lV/][row]lOx
  lmlnli[row]lWx
  LV[dc]lDx
  
#  lm ln [matrix]lPx AP
# [      F exiting with i = ]n lin [, k = ]n lknAP
 ]SF
 []SI
 []SK

 [ Attempting row reduction on ]n lmn [ by ]n lnn [ matrix:]n AP AP
 #lm ln [matrix]lPx AP
 
 lmsk [
# [  k = ]n lkn [ loop running]nAP
	   lmsi [
#	         [    i = ]n lin [ loop running]nAP
			 lilk!=F
			 lm ln [matrix]lPx AP
			 li1-dsi 0<I
			]sI li0<I
	   
	   lk1-dsk 0<K
	  ]sK lk0<K
 [1+]S0
 lmln*sk [d0=0 SU lk1-dsk 0<K]sK lk0<K
 lmln*sk 1[LU* lk1-dsk 0<K]sK lk0<K
 
 0Li*Lk*Lm*Ln*K+k
 0L0Z*LFZ*LIZ*LKZ*LYZ*LQZ*K+k
] [matrix]Z:D



# (matrix)P: Print matrix(m,n)
# @return matrix | TOS
[
 Sn  # cols
 Sm  # rows
 0Si
 0Sj
 0Sk
 []SL
 []Sl
 [2Q]SQ
 [[ ]P]S 
 [l x d0=Q d1!>Q l x]S0
 # Push all m*n elements onto stack A
 lmln*sk [SA lk1-dsk 0<L]sL lk0<L
  
 # For each row in matrix:
 lmsi [
        [
		 # Copy and print first element of row i
         LAdd0!>0n
		 # Copy and print the next n-2 elements in row i, preceded by tab spaces
		 ln2-sj [9PLAdd0!>0n lj1-dsj 0<l]sl lj0<l
		 # Print final element and trailing newline
		 #   Use `p' to prevent the weird backslash-newline thing
		 9PLAd0!>0p
		]x
		li1-dsi 0<L]sL li0<L
 
 0L Z*L0Z*LLZ*LQZ*LlZ*Li*Lj*Lk*Lm*Ln*K+k
] [matrix]Z:P

# Tests
#1 2 3 4 5 6 7 8 9
#5 3 1 [row]lRxf

#3 3 1 3 [row]lSxfAdPP
#3 3 2 3 [row]lSxfAdPP

#0 0 0 3 3 2 [row]lWxfAdPP
#386 3 3 2 2 [matrix]lWxfAdPP

#0 1 2 3 4 5 6 7 8
#9 8 7 6 5 4 3 2 1

# 1 2 3 4 5 6 7 8 9 # 3,3 matrix
# [Matrix A(3,3):]nAP
# 3 3 [matrix]lPx AP

# #0 0 _1 0 _1 0 _1 0 0 # 3,3 matrix
# 1 2 3 4 5 6 # 3,2 matrix
# [Matrix B(3,2):]nAP
# 3 2 [matrix]lPx AP

# # Result should be a 3,2 matrix:
# #   22  28
# #   49  64
# #   76  100
# [Matrix AB:]nAP

# 3 3 2 [matrix]l*x
# 3 2 [matrix]lPx AP

# [Matrix C(3,3):]nAP
# # Reuse values
# 3 3 [matrix]lPx AP
# [Identity I(3)]nAP
# 3 [matrix]lIx
# 3 3 [matrix]lPx AP
# [Matrix CI:]nAP
# 3 3 3 [matrix]l*x
# 3 3 [matrix]lPx
# [Matrix IC:]nAP
# 3 3 3 [matrix]l*x
# 3 3 [matrix]lPx

# c

3k

1 4 5 8
2 6 7 _8
6.2 2 8 1 # 22

[Original matrix:]nAP
3 4 [matrix]lPx AP
#3 3 [matrix]lPx AP
[Performing row reduction...]nAP
3 4 [matrix]lRx
[Row reduction complete:]nAP
3 4 [matrix]lPx AP

#[Calculating determinant...]nAP
#3 [matrix]lDx
#[Determinant is:]nAP
#p