# Function:
#   (dc)F: Factor a number
#	@return all prime factors numberOfFactors | TOS
[Z;Fx]sF

[
	# Declarations and initializations
	Sx		# x: number to be factored
	lxZ6/10r^Sp # p: how often to print tests
	10 4^sp	# override
	[]SL	# L: loop code
	[]SM	# M: loop code
	[]SP	# P: debug print code
	[]SK	# K: code to execute if k is a factor
	[lk2+sk]S2	# 2: increment k by 2
	[]S+
	[]S3
	[]S5
	[]S7
	[]S1
	[]S0
	[0*K+k2Q]SQ
	[*]S*
	[[=== FACTORING FAILED ===]nAP d1=*]S!
	[]SR	# R: Call stack overflow prevention
	200000Sr	# r: Call recursion depth limit
	0S?		# ?: Are we done yet?
	0Sn		# n: how many factors we've pulled out
	2Sk		# k: number to test as factor
	lxv1+Sv	# v: sqrt(x) is upper limit of prime factors
	0Si		# i: number of tests (temporary)
	1Sd		# d: testing depth
	0S$		# $: Is this number prime (enough)?


	# P: Print test counter and factor being tested
	[
		[Test ]n lin [: ]n9P [N]n [ % ]n lkn 
#		[Test ]n lin [: ]n9P lxn [ % ]n lkn 
#			[ == ]n9P lxlk%n
			[ : ]n9P K 4k lkli/n k
	AP]sP

	# 0: If k is divisible by and greater than the TOS, increment k by 2
	[dlkr!<Q lkr%0=2]s0

	# +: Set $=1 (k is prime enough)
	[1s$]s+
	
	# 1: Check for the following prime factors of k
	# Note: name is one, not L
	# Generated with: (for /F "usebackq" %A in (`primes 100`) do @echo %Al0x)|gclip
	# # `primes' is a batch file I wrote for generating prime numbers using GNU `factor'
	[
		l$d1=Q 0*K+k # If k has already survived a round of testing, then it's not going to change, so skip cycle
		lkST # T holds value of k before it's tested
#		[Testing primality of ]n lknAP
[		499l0x 
		491l0x 
		487l0x 
		479l0x 
		467l0x 
		463l0x 
		461l0x 
		457l0x 
		449l0x 
		443l0x 
		439l0x 
		433l0x 
		431l0x 
		421l0x 
		419l0x 
		409l0x 
		401l0x 
		397l0x 
		389l0x 
		383l0x 
		379l0x 
		373l0x 
		367l0x 
		359l0x 
		353l0x 
		349l0x 
		347l0x 
		337l0x 
		331l0x 
		317l0x 
		313l0x 
		311l0x 
		307l0x 
		293l0x 
		283l0x 
		281l0x 
		277l0x 
		271l0x 
		269l0x 
		263l0x 
		257l0x 
		251l0x 
		241l0x 
		239l0x 
		233l0x 
		229l0x 
		227l0x 
		223l0x 
		211l0x 
		199l0x 
		197l0x 
		193l0x 
		191l0x 
		181l0x 
		179l0x 
		173l0x 
		167l0x 
		163l0x 
		157l0x 
		151l0x 
		149l0x 
		139l0x 
		137l0x 
		131l0x 
		127l0x 
		113l0x 
		109l0x 
		107l0x 
		103l0x 
		101l0x ]Z0*K+k
	[	97l0x 
		89l0x 
		83l0x 
		79l0x 
		73l0x 
		71l0x 
		67l0x 
		61l0x 
		59l0x 
		53l0x 
		47l0x 
		43l0x 
		41l0x 
		37l0x 
		31l0x 
		29l0x 
		23l0x 
		19l0x 
		17l0x 
		13l0x 
		11l0x 
		7l0x 
		5l0x 
		3l0x] #Z0*K+k
#		x							# Use this line for thoroughness. k:i peaks at around 11.7376, 751207:64000
		Z0*K+k 7l0x 5l0x 3l0x	# Use this line for speed. k:i stabilizes around 3.7499
					# Add more checks to increase ratio
		
		lkLT=+
		
	]s1
		
	# R: Exit a bunch of calls and keep trying
	# Avoid overflowing the stack for a while
	[ld[Escaping ]np1sdQ]sR
	
	# K: What to do when we find a factor
	[1s? lksf lk2-sk lk2>2 [Quitting ]n ldnAP ld1sdQ]sK
	
	# L: Loop that tests factors
	[
		li1+si
	# Change the power in this line to indicate how often tests should be output
		li lp %0=P
		ld1+sd
		lxlk%0=K
	# Improved algorithm: After k=2, increment by two instead of one
		lk d2%+ 1+ sk
		0s$ # indicate that we haven't tested this k for primality
#	# Additional case: If last digit of k is 5, increment by two
#		lk 10%5=2
	# Function `1' from above tests the next number to see if it's composite with any of the listed numbers as factors.
	# We can run this as many times as we want, but we can't guarantee a prime number without a recursive solution (or factoring).
	# Adding more repetitions helps filter numbers, but I think (?) that
	# the benefits of this diminish quickly due to the sharp decrease in performance.
	# Edit: If a value passes through a single iteration of the filter unscathed, the rest of the cycles should skip themselves.
		l1x l1x l1x l1x #l1x l1x l1x l1x l1x l1x l1x l1x l1x l1x l1x l1x
		ld lr<R
		lklxv1+>L
		1s?
	]sL
	
	# M: Loop that keeps factoring until x==1
	[
		0s?
		lxSf # 2sk
		
		lklv>L
	# Each statement of `l?0=L' continues the loop if necessary. Increasing the number of these shouldn't hurt performance,
	# but the statement can't be nested, because that would defeat the purpose. (The purpose is to prevent a stack overflow.)
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L l?0=L 
		
		lxlf/sx Lf APdnAP
		lxv1+sv
		ln1+sn
		lx1<M
	]sM lx1<M
	
	# Print number of tests (for debugging)
	[Tests: ]n LinAP
	
	# Push number of factors
	Ln
	
	# Print error message if factoring loop exited with status 0 (factor not found)
	l?0=!
	
	# Clean up mess
	0
	LKZ*
	LLZ*
	LMZ*
	LPZ*
	LQZ*
	L2Z*
	L3Z*
	L5Z*
	L7Z*
	L1Z*
	L0Z*
	LRZ*
	L!Z*
	L*Z*
	L+Z*
	L?*
	Ld*
	Lx*
	Lk*
	Lp*
	Lr*
	Lv*
	K+k
] [dc]Z:F


# Function:
#	(dc)P: Product of n items (basically the inverse of F)
[Z;Px]sP

[
	Sn
	[]SL
	
	[ln1-dsn1<L*]sL ln1<L
	
	0
	LLZ*
	Ln*
	K+k
] [dc]Z:P


# Factorization test
#12 [dc]lFxf #[dc]lPxf cAP
#15 [dc]lFxf #[dc]lPxf cAP
#30 [dc]lFxf #[dc]lPxf cAP
#31 [dc]lFxf #[dc]lPxf cAP
#60 [dc]lFxf #[dc]lPxf cAP
#162 [dc]lFxf #[dc]lPxf cAP
#17 19 * 23 * [dc]lFxf #[dc]lPxf cAP
#100169 108401 * 158003 * [dc]lFxf #[dc]lPxf cAP
#100169d* 108401 * 158003 * [dc]lFxf #[dc]lPxf cAP

1238926361552897 93461639715357977769163558199606896584051237541638188580280321* [dc]lFx